#ifndef MODELS_HPP
#define MODELS_HPP

#include <headers.hpp>
#include <shaders.hpp>
#include <renderable_object.hpp>
#include <textures.hpp>
#include <lights.hpp>

#include <assimp/Importer.hpp>
#include <assimp/scene.h>
#include <assimp/postprocess.h>

namespace models
{

struct vertex_t
{
    glm::vec3 coordinate;
    glm::vec2 texture_coord;
    glm::vec3 normal;
};

using namespace textures;

/*
 * Responsible for loading, storing, drawing
 * meshes.
 */
class my_mesh
{
public:
    using vertices_ptr = std::unique_ptr<std::vector<vertex_t>>;
    using indices_ptr  = std::unique_ptr<std::vector<GLuint>>;
    using textures_ptr = std::unique_ptr<std::vector<texture_t>>;
    /*
     * my_mesh takes ownership of those data
     * structures! Make sure to not share this
     * stuff with others!
     */
    my_mesh(vertices_ptr vertx,
            indices_ptr indx,
            textures_ptr texts);
    void render(shaders::my_small_shaders* shader);
private:
    void setup_mesh();
private:
    GLuint VAO,VBO,EBO;
    vertices_ptr  vertices;
    indices_ptr   indices; //For EBO
    textures_ptr textures;
};

class my_model;
using model_ptr = std::shared_ptr<my_model>;

//Nice way for passing this option
enum class z_axis {
    revert,
    normal
};

using mesh_ptr = std::unique_ptr<my_mesh>;

/*
 * Responsible for loading models and creating
 * all the meshes data structure which then are
 * used for drawing purpose
 */
class model_loader;

using model_loader_ptr = std::shared_ptr<model_loader>;

class model_loader
{
    /*
     * process_model is the function which traverse the
     * scene generated by Assimp and extract all the
     * mesh information
     */
    void process_model(aiNode* node, const aiScene* scene);
    /*
     * For each mesh in the model, generate
     * the relative my_mesh
     */
    mesh_ptr process_mesh(aiMesh* mesh,const aiScene* scene);
    /*
     * Extract the texture information for
     * the mesh
     */
    my_mesh::textures_ptr process_texture(const aiMaterial *material,
                                          aiTextureType type);
public:
    model_loader(const std::string& path, z_axis revert_z);
    bool load_model();
    std::vector<mesh_ptr>& get_mesh();
    static model_loader_ptr load(const std::string& path,
                                 z_axis revert_z = z_axis::normal) {
        auto model = std::make_shared<model_loader>( path, revert_z );
        if( false == model->load_model() ) {
            return nullptr;
        }
        return model;
    }
private:
    std::string model_path,
    model_directory;
    std::vector<mesh_ptr> meshes;
    //For models which are 'reverted'
    bool revert_z_axis;
};

/*
 * Handle the loaded model, responsible for
 * rendering.
 */
class my_model : public model_loader,
        public lights::object_lighting,
        public renderable::renderable_object,
        public movable::movable_object
{
public:
    my_model(shaders::my_small_shaders* shad,
             const std::string& model_path,
             const glm::vec3& def_object_color,
             z_axis revert_z);

    void prepare_for_render() override;
    void render() override;
    void clean_after_render() override;

    static model_ptr create(shaders::my_small_shaders* shader,
                            const std::string& path,
                            const glm::vec3& color = glm::vec3(0.0),
                            z_axis revert_z = z_axis::normal) {
        return std::make_shared< my_model >( shader, path , color, revert_z );
    }
private:
    shaders::my_small_shaders* shader;
    glm::vec3 object_color;
};

}

#endif
