#include <headers.hpp>
#include <shaders.hpp>
#include <renderable_object.hpp>
#include <textures.hpp>
#include <lights.hpp>

#include <assimp/Importer.hpp>
#include <assimp/scene.h>
#include <assimp/postprocess.h>

namespace models
{

struct vertex_t
{
	glm::vec3 coordinate;
	glm::vec2 texture_coord;
	glm::vec3 normal;
};

using namespace textures;

/*
 * Responsible for loading, storing, drawing
 * meshes.
 */
class my_mesh
{
public:
	using vertices_ptr = std::unique_ptr<std::vector<vertex_t>>;
	using indices_ptr  = std::unique_ptr<std::vector<GLuint>>;
	using textures_ptr = std::unique_ptr<std::vector<texture_t>>;
	/*
	 * my_mesh takes ownership of those data
	 * structures! Make sure to not share this
	 * stuff with others!
	 */
	my_mesh(shaders::my_small_shaders* shad,
		vertices_ptr vertx,
		indices_ptr indx,
		textures_ptr texts);
	void render();
private:
	void setup_mesh();
private:
	shaders::my_small_shaders* shader;
	GLuint VAO,VBO,EBO;
	vertices_ptr  vertices;
	indices_ptr   indices; //For EBO
	textures_ptr textures;
};

class my_model;
using model_ptr = std::shared_ptr<my_model>;

/*
 * Responsible for loading models and creating
 * all the meshes data structure which then are
 * used for drawing purpose
 */
class my_model : public lights::object_lighting,
		public renderable::renderable_object,
		public movable::movable_object
	//std::enable_shared_from_this< my_model >
{
public:
	using mesh_ptr = std::unique_ptr<my_mesh>;
	my_model(shaders::my_small_shaders* shad,
		const std::string& model_path);

	void set_transformations(glm::mat4 view,glm::mat4 projection) override;
	void prepare_for_render() override;
	void render() override;
	void clean_after_render() override;

	static model_ptr create(shaders::my_small_shaders* shader,
					const std::string& path) {
		return std::make_shared< my_model >( shader, path );
	}

private:
	bool load_model();
	/*
	 * process_model is the function which traverse the
	 * scene generated by Assimp and extract all the
	 * mesh information
	 */
	void process_model(aiNode* node, const aiScene* scene);
	/*
	 * For each mesh in the model, generate
	 * the relative my_mesh
	 */
	mesh_ptr process_mesh(aiMesh* mesh,const aiScene* scene);
	/*
	 * Extract the texture information for
	 * the mesh
	 */
	my_mesh::textures_ptr process_texture(const aiMaterial *material,
			aiTextureType type);
private:
	shaders::my_small_shaders* shader;
	std::string model_path,
			model_directory;
	std::vector<mesh_ptr> meshes;
	glm::mat4 projection_matrix,
			view_matrix;
};

}
