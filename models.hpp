#include <headers.hpp>
#include <shaders.hpp>
#include <renderable_object.hpp>

#include <assimp/Importer.hpp>
#include <assimp/scene.h>
#include <assimp/postprocess.h>

namespace models
{

struct vertex_t
{
	glm::vec3 coordinate;
	glm::vec3 normal;
	glm::vec2 texture_coord;
};

enum class texture_type
{

};

struct texture_t
{
	GLuint id;
	texture_type type;
};

/*
 * Responsible for loading, storing, drawing
 * meshes.
 */
class my_mesh
{
public:
	using vertices_ptr = std::unique_ptr<std::vector<vertex_t>>;
	using indices_ptr  = std::unique_ptr<std::vector<GLuint>>;
	using textures_ptr = std::unique_ptr<std::vector<texture_t>>;
	/*
	 * my_mesh takes ownership of those data
	 * structures! Make sure to not share this
	 * stuff with others!
	 */
	my_mesh(shaders::my_small_shaders* shad,
		vertices_ptr vertx,
		indices_ptr indx,
		textures_ptr texts);
	void render();
private:
	void setup_mesh();
private:
	shaders::my_small_shaders* shader;
	GLuint VAO,VBO,EBO;
	vertices_ptr  vertices;
	indices_ptr   indices; //For EBO
	textures_ptr textures;
};

/*
 * Responsible for loading models and creating
 * all the meshes data structure which then are
 * used for drawing purpose
 */
class my_model
{
public:
	using mesh_ptr = std::unique_ptr<my_mesh>;
	my_model(shaders::my_small_shaders* shad,
		const std::string& model_path);

	void render();
private:
	bool load_model();
	/*
	 * process_model is the function which traverse the
	 * scene generated by Assimp and extract all the
	 * mesh information
	 */
	void process_model(aiNode* node, const aiScene* scene);
	/*
	 * For each mesh in the model, generate
	 * the relative my_mesh
	 */
	mesh_ptr process_mesh(aiMesh* mesh,const aiScene* scene);
private:
	shaders::my_small_shaders* shader;
	std::string model_path,
			model_directory;
	std::vector<mesh_ptr> meshes;
};

}
