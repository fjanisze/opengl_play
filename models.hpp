#ifndef MODELS_HPP
#define MODELS_HPP

#include <headers.hpp>
#include <shaders.hpp>
#include <renderable_object.hpp>
#include <textures.hpp>
#include <lights.hpp>

#include <assimp/Importer.hpp>
#include <assimp/scene.h>
#include <assimp/postprocess.h>

namespace models
{

struct vertex_t
{
    glm::vec3 coordinate;
    glm::vec2 texture_coord;
    glm::vec3 normal;
};

using namespace textures;

/*
 * Responsible for loading, storing, drawing
 * meshes.
 */
class my_mesh
{
public:
    using pointer = std::unique_ptr< my_mesh >;
    using meshes = std::vector< pointer >;
    using vertices_ptr = std::unique_ptr<std::vector<vertex_t>>;
    using indices_ptr  = std::unique_ptr<std::vector<GLuint>>;
    using textures_ptr = std::unique_ptr<std::vector<texture_t>>;
    /*
     * my_mesh takes ownership of those data
     * structures! Make sure to not share this
     * stuff with others!
     */
    my_mesh(vertices_ptr vertx,
            indices_ptr indx,
            textures_ptr texts);
    void render( shaders::Shader* shader ) const;
private:
    void setup_mesh();
private:
    GLuint VAO,VBO,EBO;
    vertices_ptr vertices;
    indices_ptr  indices; //For EBO
    textures_ptr textures;
};

class my_model;
using model_ptr = std::shared_ptr<my_model>;

//Nice way for passing this option
enum class z_axis {
    revert,
    normal
};

using mesh_ptr = std::unique_ptr<my_mesh>;

/*
 * Responsible for loading models and creating
 * all the meshes data structure which then are
 * used for drawing purpose
 */
class model_loader;

using model_loader_ptr = std::shared_ptr<model_loader>;

class model_loader
{
    /*
     * process_model is the function which traverse the
     * scene generated by Assimp and extract all the
     * mesh information
     */
    void process_model(aiNode* node, const aiScene* scene);
    /*
     * For each mesh in the model, generate
     * the relative my_mesh
     */
    mesh_ptr process_mesh(aiMesh* mesh,const aiScene* scene);
    /*
     * Extract the texture information for
     * the mesh
     */
    my_mesh::textures_ptr process_texture(const aiMaterial *material,
                                          aiTextureType type);
public:
    using pointer = std::shared_ptr< model_loader >;
    model_loader(const std::string& path, z_axis revert_z = models::z_axis::normal);
    bool load_model();
    my_mesh::meshes& get_mesh();
    GLfloat get_model_height();
private:
    std::string model_path;
    std::string model_directory;
    my_mesh::meshes meshes;
    GLfloat model_height;
    //For models which are 'reverted'
    bool revert_z_axis;
};

/*
 * Handle the loaded model, responsible for
 * rendering.
 */
class my_model : public model_loader,
        public renderer::Renderable,
        public scene::Movable
{
public:
    my_model(const std::string& model_path,
             const glm::vec4 &def_object_color,
             z_axis revert_z);

    static model_ptr create(const std::string& path,
                            const glm::vec4& color = glm::vec4(0.0,0.0,0.0,1.0),
                            z_axis revert_z = z_axis::normal) {
        return std::make_shared< my_model >( path , color, revert_z );
    }
};

}

#endif
